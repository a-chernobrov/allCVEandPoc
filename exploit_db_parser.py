import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import datetime
import hashlib
import re
from database import save_vulnerability, create_database

BASE_URL = "https://www.exploit-db.com/"
SEARCH_URL = "https://www.exploit-db.com/search"

def parse_exploits():
    """
    Парсит эксплойты с exploit-db.com используя их API для поиска.
    """
    print("Запрос к API поиска Exploit-DB...")
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',
            'X-Requested-With': 'XMLHttpRequest',
        }
        
        page = 0
        while True:
            # Параметры для DataTables
            payload = {
                'draw': 1,
                'start': page * 100,
                'length': 100,  # Получаем 100 записей
                'search[value]': '',
                'search[regex]': 'false'
            }

            response = requests.get(SEARCH_URL, headers=headers, params=payload)
            response.raise_for_status()
            data = response.json()

            exploits = data.get('data', [])
            if not exploits:
                print("Больше эксплойтов не найдено, завершение работы.")
                break

            for exploit in exploits:
                date_str = exploit.get('date_published', '')

                description_list = exploit.get('description', [])
                if len(description_list) > 1:
                    description = description_list[1]
                else:
                    description = ""

                soup_download = BeautifulSoup(exploit.get('download', ''), 'html.parser')
                link_tag = soup_download.find('a')
                exploit_link = urljoin(BASE_URL, link_tag['href']) if link_tag else ""

                cve_id_text = "N/A"
                codes = exploit.get('code', [])
                for code in codes:
                    if code.get('code_type') == 'cve':
                        cve_id_text = code.get('code')
                        break
                
                try:
                    year = datetime.datetime.strptime(date_str, '%Y-%m-%d').year
                except (ValueError, TypeError):
                    year = datetime.datetime.now().year

                cve_id_upper = cve_id_text.upper() if cve_id_text else "N/A"

                if cve_id_upper == "N/A":
                    unique_id = "N/A-" + hashlib.md5(description.encode()).hexdigest()
                    save_vulnerability(str(year), unique_id, description, [exploit_link])
                    print(f"Сохранена уязвимость: {unique_id}")
                else:
                    # Проверяем, соответствует ли CVE ID формату YYYY-NNNN...
                    if re.match(r'^\d{4}-\d{4,}$', cve_id_upper):
                        cve_id_upper = f"CVE-{cve_id_upper}"
                    
                    save_vulnerability(str(year), cve_id_upper, description, [exploit_link])
                    print(f"Сохранена уязвимость: {cve_id_upper}")
            
            page += 1

    except requests.exceptions.RequestException as e:
        print(f"Ошибка при запросе к {SEARCH_URL}: {e}")
        return
    except ValueError:
        print("Не удалось декодировать JSON.")
        print("Полученный ответ:", response.text)
        return

def main():
    """
    Главная функция для запуска парсера.
    """
    create_database()
    print("Парсер Exploit-DB запущен.")
    parse_exploits()
    print("Парсинг Exploit-DB завершен.")

if __name__ == '__main__':
    main()